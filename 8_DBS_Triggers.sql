--USE THE DATABASE
USE APU_SEPL
GO
---===========================================
--- STEP 08: GRANT CONTROL ON DATABASE, TABLES
---===========================================

---=======================================================
--- MEMBER TABLE: AFTER INSERTING, CONCAT 'APU' + MEM_ID
---=======================================================
CREATE OR ALTER TRIGGER MEM_LOG_ID_INSERTED
ON [MEMBER]
AFTER INSERT
AS
BEGIN
    SET NOCOUNT ON;

    UPDATE M
    SET MEM_LOG_ID = 'APU' + CAST(I.MEM_ID AS VARCHAR(8))
    FROM [MEMBER] M
    INNER JOIN INSERTED I ON M.MEM_ID = I.MEM_ID;
END
GO

--TEST ACCESS
INSERT INTO DBO.[MEMBER] (MEM_NAME, MEM_PHONE_NO)
VALUES ('Evelyn Jung', '0195677812'),
       ('Ray Foong', '009877889');

Execute as User = 'YEE'
Execute as User = '50005'
SELECT USER_NAME()
REVERT 
SELECT * FROM MEMBER


---=============================================================================
--- MEMBER TABLE: INSTEAD OF INSERTING INTO VIEW, INSERT THE ACTUAL RECORDS
---==============================================================================

CREATE OR ALTER TRIGGER NEW_MEM_INSERTED
ON ALL_MEMBER_INFO_VIEW
INSTEAD OF INSERT
AS
BEGIN
	SET NOCOUNT ON;

    INSERT INTO MEMBER(MEM_NAME, MEM_PHONE_NO)
    SELECT MEM_NAME, MEM_PHONE_NO
    FROM INSERTED;
END;

--TEST ACCESS
INSERT INTO ALL_MEMBER_INFO_VIEW (MEM_NAME, MEM_PHONE_NO)
VALUES ('Raymond Khoo', '0198890988'),
       ('Darren Kim', '0120911234');

INSERT INTO ALL_MEMBER_INFO_VIEW (MEM_NAME, MEM_PHONE_NO)
VALUES ('Evelyn Jung', '0195677812'),
       ('Ray Foong', '009877889');


--TEST ACCESS
Execute as User = 'YEE'
Execute as User = '50005'
SELECT USER_NAME()
REVERT 

OPEN SYMMETRIC KEY SIMKEY_MEMBER_STAFF
DECRYPTION BY CERTIFICATE CERT_MEMBER_STAFF
SELECT MEM_ID, MEM_NAME, CONVERT(VARCHAR, DECRYPTBYKEY(MEM_ADDRESS)) AS MEM_ADDRESS FROM ALL_MEMBER_INFO_VIEW
CLOSE SYMMETRIC KEY SIMKEY_MEMBER_STAFF



---=============================================================
--- MEMBER TABLE: UPDATE ACTUAL DATA AFTER UPDATE BY STORE_CLERK IN THE ALL_MEMBER_VIEW
---==============================================================

CREATE OR ALTER TRIGGER UPDATE_BY_STORE_CLERK
ON ALL_MEMBER_INFO_VIEW
INSTEAD OF UPDATE
AS
BEGIN
    SET NOCOUNT ON;

    UPDATE M
    SET MEM_NAME = I.MEM_NAME,
		MEM_PHONE_NO = I.MEM_PHONE_NO       
    FROM [MEMBER] M
    INNER JOIN INSERTED I ON M.MEM_ID = I.MEM_ID;
	PRINT 'NOTE THAT NON-CONFIDENTIAL DATA SUCH AS NAME AND PHONE NUMBER WILL ONLY BE UPDATED INTO THE SYSTEM, 
	WHERE MEMBERS ARE REQUIRED TO UPDATE THEIR NRIC/PN AND ADDRESS BY THEMSELVES.'
END;

--TEST ACCESS
OPEN SYMMETRIC KEY SIMKEY_MEMBER_STAFF DECRYPTION BY CERTIFICATE CERT_MEMBER_STAFF
UPDATE ALL_MEMBER_INFO_VIEW SET MEM_PHONE_NO = '200345999', MEM_NRIC_PN = ENCRYPTBYKEY(KEY_GUID('SIMKEY_MEMBER_STAFF'), '22231111'), 
MEM_ADDRESS = ENCRYPTBYKEY(KEY_GUID('SIMKEY_MEMBER_STAFF'), '33, JALAN SECTION 33/33, PJ')
WHERE MEM_ID = '50003'
CLOSE SYMMETRIC KEY SIMKEY_MEMBER_STAFF

Execute as User = 'YEE'
Execute as User = '50005'

UPDATE ALL_MEMBER_INFO_VIEW SET MEM_LOG_ID = 'APU501K' WHERE MEM_ID = '50005'	--ALTHOUGH THE SYSTEM RETURNS ROW AFFECTED, HOWEVER THE UPDATE WILL NOT REFLECT TO THE VIEW BECAUSE IT LOG_ID, STATUS AND REGISTER_DATE IS NOT CONSIDERED IN THE UPDATE TRIGGER

SELECT USER_NAME()
REVERT 
SELECT * FROM ALL_MEMBER_INFO_VIEW

OPEN SYMMETRIC KEY SIMKEY_MEMBER_STAFF DECRYPTION BY CERTIFICATE CERT_MEMBER_STAFF
SELECT * FROM ALL_MEMBER_INFO_VIEW
CLOSE SYMMETRIC KEY SIMKEY_MEMBER_STAFF

UPDATE ALL_MEMBER_INFO_VIEW SET MEM_PHONE_NO = '0222288990' WHERE MEM_ID = 50004
UPDATE ALL_MEMBER_INFO_VIEW SET MEM_NRIC_PN = ENCRYPTBYKEY(KEY_GUID('SIMKEY_MEMBER_STAFF'), '0123456789') WHERE MEM_ID = 50003

---=====================================================================================
--- MEMBER TABLE: ENCRYPT MEMBER DATA AFTER UPDATE BY MEMBER 
---=====================================================================================

CREATE OR ALTER TRIGGER UPDATE_BY_MEMBER
ON OWN_MEMBER_INFO_VIEW
INSTEAD OF UPDATE
AS
BEGIN
    SET NOCOUNT ON;

    -- Update the Passport and Address columns with encrypted values
    OPEN SYMMETRIC KEY SIMKEY_MEMBER DECRYPTION BY CERTIFICATE CERT_MEMBER

    UPDATE M
    SET MEM_NRIC_PN = ENCRYPTBYKEY(KEY_GUID('SIMKEY_MEMBER'), I.Decrypted_NRIC_PN),
		MEM_NAME = I.MEM_NAME,
        MEM_ADDRESS = ENCRYPTBYKEY(KEY_GUID('SIMKEY_MEMBER'), I.Decrypted_ADDRESS),
		MEM_PHONE_NO = I.MEM_PHONE_NO

    FROM [MEMBER] M
    INNER JOIN INSERTED I ON M.MEM_ID = I.MEM_ID;

    CLOSE SYMMETRIC KEY SIMKEY_MEMBER;

END;

--TEST ACCESS
UPDATE OWN_MEMBER_INFO_VIEW SET MEM_PHONE_NO = '200345011', Decrypted_NRIC_PN = '22231111', Decrypted_ADDRESS = '33, JALAN SECTION 33/33, PJ'
WHERE MEM_ID = '50003'

Execute as User = 'YEE'
Execute as User = '50005'

UPDATE OWN_MEMBER_INFO_VIEW SET MEM_LOG_ID = 'APU501K' WHERE MEM_ID = '50005'	--ALTHOUGH THE SYSTEM RETURNS ROW AFFECTED, HOWEVER THE UPDATE WILL NOT REFLECT TO THE VIEW BECAUSE LOG_ID, STATUS AND REGISTER_DATE IS NOT CONSIDERED IN THE UPDATE TRIGGER
UPDATE OWN_MEMBER_INFO_VIEW SET MEM_PHONE_NO = '1000000088' WHERE MEM_ID = USER_NAME()

SELECT USER_NAME()
REVERT 
SELECT * FROM OWN_MEMBER_INFO_VIEW

OPEN SYMMETRIC KEY SIMKEY_MEMBER DECRYPTION BY CERTIFICATE CERT_MEMBER
SELECT * FROM OWN_MEMBER_INFO_VIEW
CLOSE SYMMETRIC KEY SIMKEY_MEMBER



---===========================================
--- MEMBER TABLE: EXPIRED MEMBERSHIP 
---===========================================

CREATE OR ALTER TRIGGER TRG_UPDATE_MEM_STATUS
ON MEMBER
AFTER INSERT, UPDATE
AS 
BEGIN
	SET NOCOUNT ON;

    DECLARE @CurrentDate DATE
    SET @CurrentDate = CAST(GETDATE() AS DATE)

    -- CHECK IF REGISTRATION DATE IS GREATER THAN ONE YEAR 
    UPDATE MEMBER
    SET MEM_STATUS = 'EXPIRED'
    WHERE DATEDIFF(YEAR, MEM_REGISTER_DATE, @CurrentDate) >= 1
      AND MEM_STATUS <> 'EXPIRED'; -- SKIP, IF THE MEM_STATUS IS ALREADY EXPIRED
END;


--TEST ACCESS
 UPDATE MEMBER
 set MEM_STATUS = 'ACTIVE'
 where MEM_ID = 50002

-- UNCOMMENT THE FOLLOWING IF NECESSARY
--DROP TRIGGER TRG_UPDATE_MEM_STATUS

--CHECKING PURPOSE
SELECT * FROM MEMBER


---=====================================================
--- TRANSACTION TABLE: INSERT RECORDS INTO 2 TABLES 
---=====================================================

-- INSERT INTO THE TRANSACTION AND EQ_TRANS TABLE AT ONCE

SELECT USER_NAME()
REVERT

GRANT EXECUTE ON OBJECT::DBO.SP_CREATE_TRANSACTION TO [MEMBERS];
--REVOKE EXECUTE ON OBJECT::DBO.SP_CREATE_TRANSACTION TO [MEMBERS];
DENY EXECUTE ON OBJECT::DBO.SP_CREATE_TRANSACTION TO [DBA]; -- TO RESTRICT ACCESS FOR DBA

EXECUTE AS USER = '50004'
SELECT USER_NAME()
REVERT

CREATE OR ALTER PROCEDURE SP_CREATE_TRANSACTION
    @EquipmentID INT,
    @QuantityPurchased INT
AS
BEGIN
    IF @EquipmentID IS NOT NULL AND EXISTS (SELECT 1 FROM dbo.EQUIPMENT WHERE EQ_ID = @EquipmentID)
    BEGIN
        DECLARE @AvailableQuantity INT;

        -- Check if there is enough quantity available for the transaction
        SELECT @AvailableQuantity = EQ_QUANTITY FROM EQUIPMENT WHERE EQ_ID = @EquipmentID;

        IF @AvailableQuantity >= @QuantityPurchased
        BEGIN
            BEGIN TRANSACTION;

            -- Insert into the Transaction table
            INSERT INTO [Transaction] (TRANS_DATE, MEM_ID)
            VALUES (GETDATE(), USER_NAME());

            -- Retrieve the generated transaction ID
            DECLARE @generatedTransID INT;
            SET @generatedTransID = SCOPE_IDENTITY();

            INSERT INTO EQ_trans (TRANS_ID, EQ_ID, TRANS_QUANT_PURCHASED)
            VALUES (@generatedTransID, @EquipmentID, @QuantityPurchased);

            -- Update the equipment quantity
            UPDATE EQUIPMENT
            SET EQ_QUANTITY = EQ_QUANTITY - @QuantityPurchased
            WHERE EQ_ID = @EquipmentID;

            COMMIT;
        END;
        ELSE
        BEGIN
            RAISERROR('NOT ENOUGH QUANTITY AVAILABLE FOR THE TRANSACTION.', 16, 1);
        END;
    END;
    ELSE
    BEGIN
        RAISERROR('EQUIPMENTID DOES NOT EXIST IN THE EQUIPMENT TABLE.', 16, 1);
    END;
END;


-- UNCOMMENT THE FOLLOWING TO EXECUTE THE FUNCTION
--exec SP_CREATE_TRANSACTION  @EquipmentID = 1,    @QuantityPurchased = 10

-- CHECK WHETHER THE RECORDS ARE INSERTED
select * from [TRANSACTION]
select * from EQ_TRANS
select * from EQUIPMENT

---=====================================================
--- TRANSACTION TABLE: CHECK DATE WITHIN 3 DAYS
---=====================================================
EXECUTE AS USER = '50004'
SELECT USER_NAME()

CREATE OR ALTER TRIGGER TRG_CHECK_RETURN_DATE
ON [Transaction]
INSTEAD OF DELETE
AS
BEGIN
    IF EXISTS (SELECT 1 FROM DELETED)
    BEGIN
        SET NOCOUNT ON;

        DECLARE @CurrentDate DATE
        SET @CurrentDate = CAST(GETDATE() AS DATE)

        -- COMPARE THE TRANSACTION DATE AND THE CURRENT DATE
        IF NOT EXISTS (
            SELECT 1
            FROM DELETED
            WHERE DATEDIFF(DAY, CAST(TRANS_DATE AS DATE), @CurrentDate) <= 3
        )
        BEGIN
            RAISERROR('ALERT!!! YOU CAN ONLY RETURN ITEMS WITHIN 3 DAYS OF PURCHASE.', 16, 1)
            ROLLBACK TRANSACTION;
            RETURN;
        END;

		 -- Update the equipment quantity back in EQUIPMENT
        UPDATE eq
        SET eq.EQ_QUANTITY = eq.EQ_QUANTITY + e.TRANS_QUANT_PURCHASED
        FROM EQUIPMENT eq
        INNER JOIN EQ_trans e ON eq.EQ_ID = e.EQ_ID
        INNER JOIN DELETED d ON e.TRANS_ID = d.TRANS_ID
		where e.TRANS_ID = d.TRANS_ID AND eq.EQ_ID = e.EQ_ID

        DELETE FROM EQ_trans
        WHERE TRANS_ID IN (SELECT TRANS_ID FROM DELETED);

        DELETE FROM [Transaction]
        WHERE TRANS_ID IN (SELECT TRANS_ID FROM DELETED);
    END;
END;

--TEST ACCESS
--DELETE FROM [TRANSACTION] WHERE TRANS_ID = 10007;
--DELETE FROM [TRANSACTION] WHERE TRANS_ID = 10015;

---==============================================================
--- TRANSACTION TABLE: UPDATE TRANSACTION 
---==============================================================

-- INSERT INTO THE TRANSACTION AND EQ_TRANS TABLE AT ONCE

GRANT EXECUTE ON OBJECT::DBO.SP_UPDATE_TRANSACTION TO [MEMBERS];
--REVOKE EXECUTE ON OBJECT::DBO.SP_UPDATE_TRANSACTION TO [MEMBERS];

EXECUTE AS USER = '50004'
SELECT USER_NAME()
REVERT


CREATE OR ALTER PROCEDURE SP_UPDATE_TRANSACTION
    @TRANSID INT,
    @NEWQUANT INT
AS
BEGIN
    IF @TRANSID IS NOT NULL AND EXISTS (SELECT 1 FROM dbo.[TRANSACTION] WHERE TRANS_ID = @TRANSID)
    BEGIN
        BEGIN TRANSACTION;

        -- Retrieve the current QuantityPurchased from the transaction
        DECLARE @OLDQUANT INT;
        DECLARE @EQUIPID INT;
		DECLARE @ORIEQUIPQUANT INT;

        SELECT @OLDQUANT = TRANS_QUANT_PURCHASED
        FROM EQ_TRANS
        WHERE TRANS_ID = @TRANSID;

        SELECT @EQUIPID = e.EQ_ID, @ORIEQUIPQUANT = eq.EQ_QUANTITY
        FROM EQ_TRANS e
		INNER JOIN EQUIPMENT eq
		oN e.EQ_ID = eq.EQ_ID
        WHERE TRANS_ID = @TRANSID;

        -- Check if the new quantity is valid and the action can be performed
        IF @ORIEQUIPQUANT = 0 AND (@NEWQUANT > @OLDQUANT OR @NEWQUANT < 0)
        BEGIN
            ROLLBACK; -- If the condition is not met, rollback the transaction
            RAISERROR('INVALID EQUIPMENT QUANTITY. THE UPDATE IS TERMINATED.', 16, 1);
            RETURN; -- Return from the procedure
        END;

        -- Update the equipment quantity with the difference
        UPDATE EQUIPMENT
        SET EQ_QUANTITY = (EQ_QUANTITY + @OLDQUANT) - @NEWQUANT
        WHERE EQ_ID = @EQUIPID;

        -- Update the transaction with the new QuantityPurchased
        UPDATE EQ_trans
        SET TRANS_QUANT_PURCHASED = @NEWQUANT
        WHERE TRANS_ID = @TRANSID;

        COMMIT;
    END;
    ELSE
    BEGIN
        RAISERROR('TRANSACTIONID DOES NOT EXIST IN THE TRANSACTION TABLE.', 16, 1);
    END;
END;

EXEC SP_UPDATE_TRANSACTION @TRANSID = 10004, @NEWQUANT = 13;

--TEST ACCESS
SELECT * FROM [TRANSACTION]
SELECT * FROM EQ_TRANS
SELECT * FROM EQUIPMENT

---==============================================================
--- GENERAL: DROP TABLE WARNING
---==============================================================

CREATE OR ALTER TRIGGER DROP_TABLE_WARNING 
ON DATABASE
FOR DROP_TABLE
AS
PRINT 'You must disable Trigger DROP_TABLE_WARNING to drop tables!'
ROLLBACK;

--TEST ACCESS
EXECUTE AS USER = 'EVONNE'
SELECT USER_NAME()

CREATE TABLE QWE (QWE INT PRIMARY KEY, MKI INT);
DROP TABLE QWE
DISABLE TRIGGER DROP_TABLE_WARNING ON DATABASE
REVERT 